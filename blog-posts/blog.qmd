---
title: "Which AI model writes the best R code?"
author: "Sara Altman, Simon Couch"
format: gfm
execute: 
    echo: false
    warning: false
knitr: 
  opts_chunk:
    message: false
---

```{r libraries}
library(tidyverse)
library(vitals)
library(gt)
library(ggrepel)
library(fs)
```

```{r setup}
# Assumes more output than input
# Based on ratios from eval
COST_BLEND_INPUT_MULTIPLIER <- 1 / 3
EXCLUDED_MODELS <-
  c(
    "gpt_oss_120b",
    "gpt_oss_20b",
    "sonnet_4", # no thinking
    "gpt_o3_mini",
    "gpt_o4_mini",
    "gpt_o1"
  )

tasks <-
  dir_ls(here::here("results_rds"), glob = "*.rds") |>
  set_names(\(x) path_ext_remove(basename(x))) |>
  map(read_rds)

are_eval <-
  tasks |>
  imap(
    \(x, idx) {
      vitals_bind(x) |>
        mutate(model = idx)
    }
  ) |>
  list_rbind() |>
  mutate(
    model_join = model,
    model = fct_recode(
      model,
      `Claude Sonnet 4\n(No Thinking)` = "sonnet_4",
      `Claude Sonnet 4` = "sonnet_4_thinking",
      `Claude Sonnet 4.5` = "sonnet_4_5_thinking",
      `Claude Opus 4.1` = "opus_4_1_thinking",
      `Claude Haiku 4.5` = "haiku_4_5_thinking",
      `GPT-4.1` = "gpt_4_1",
      `o1` = "gpt_o1",
      `o3-mini` = "gpt_o3_mini",
      `o3` = "gpt_o3",
      `o4-mini` = "gpt_o4_mini",
      `GPT-5` = "gpt_5",
      `GPT-5 mini` = "gpt_5_mini",
      `GPT-5 nano` = "gpt_5_nano",
      `gpt-oss-20b` = "gpt_oss_20b",
      `gpt-oss-120b` = "gpt_oss_120b"
    ),
    model = fct_reorder(model, score, .fun = \(x) sum(x == "C", na.rm = TRUE)),
    score = fct_recode(
      score,
      "Correct" = "C",
      "Partially Correct" = "P",
      "Incorrect" = "I"
    )
  ) |>
  filter(!model_join %in% EXCLUDED_MODELS)

model_order <-
  are_eval$model |>
  # fct_collapse(
  #   "Claude Sonnet 4" =
  #     c("Claude Sonnet 4\n(No Thinking)", "Claude Sonnet 4\n(Thinking)")
  # ) |>
  levels()

model_prices <-
  tribble(
    ~Name               , ~Input , ~Output , ~model_join           ,
    "Claude Sonnet 4"   ,  3.00  , 15.00   , "sonnet_4"            ,
    "Claude Sonnet 4"   ,  3.00  , 15.00   , "sonnet_4_thinking"   ,
    "Claude Sonnet 4.5" ,  3.00  , 15.00   , "sonnet_4_5_thinking" ,
    "Claude Opus 4.1"   , 15.00  , 75.00   , "opus_4_1"            ,
    "Claude Haiku 4.5"  ,  1.00  ,  5.00   , "haiku_4_5_thinking"  ,
    "o3"                , 10.00  , 40.00   , "gpt_o3"              ,
    "o4-mini"           ,  1.10  ,  4.40   , "gpt_o4_mini"         ,
    "GPT-4.1"           ,  2.00  ,  8.00   , "gpt_4_1"             ,
    "o1"                , 15.00  , 60.00   , "gpt_o1"              ,
    "o3-mini"           ,  1.10  ,  4.40   , "gpt_o3_mini"         ,
    "GPT-5"             ,  1.25  , 10.00   , "gpt_5"               ,
    "GPT-5 mini"        ,  0.25  ,  2.00   , "gpt_5_mini"          ,
    "GPT-5 nano"        ,  0.05  ,  0.40   , "gpt_5_nano"          ,
    "gpt-oss-20b"       ,  0.00  ,  0.00   , "gpt_oss_20b"         ,
    "gpt-oss-120b"      ,  0.00  ,  0.00   , "gpt_oss_120b"
  ) |>
  arrange(desc(match(Name, model_order)))

are_costs <-
  tasks |>
  imap(\(x, idx) x$get_cost() |> mutate(model_join = idx)) |>
  list_rbind() |>
  filter(source != "scorer") |>
  mutate(price = str_extract(price, "\\d+\\.\\d+") |> as.double()) |>
  left_join(model_prices, by = "model_join") |>
  mutate(
    price = if_else(
      is.na(price),
      input * Input / 1e6 + output * Output / 1e6,
      price
    )
  ) |>
  select(model = Name, model_id = model, model_join, input, output, price)

are_cost_summary <-
  are_costs |>
  summarize(
    min_input = min(input),
    max_input = max(input),
    min_output = min(output),
    max_output = max(output),
    avg_io_ratio = median(input / output),
    total_cost = sum(price)
  ) |>
  mutate(
    across(min_input:max_output, \(x) signif(x, 4) |> format(big.mark = ","))
  )
```


**LLMs can now help you write R code. There are many available models, so which one should you pick?**

We evaluated how well various models generate R code. To do so, we used the [vitals package](https://vitals.tidyverse.org/), a framework for LLM evaluation. vitals contains functions for measuring the effectiveness of an LLM, as well as a dataset of challenging R coding problems and their solutions. We evaluated model performance on this set of coding problems. 

In June, we ran an earlier version of this evaluation with the models available at the time. You can read that blog post [here](https://posit.co/blog/r-llm-evaluation/). If you're interested in Python code generation, we also evaluated how well various models perform on [Pandas code generation](https://posit.co/blog/python-llm-evaluation/). 

## Current recommendation: OpenAI GPT-5, OpenAI o4-mini, or Claude Sonnet 4

```{r main-plot, dpi=300}
are_eval |>
  ggplot(aes(y = model, fill = score)) +
  geom_bar(position = "fill") +
  scale_fill_manual(
    breaks = rev,
    values = c(
      "Correct" = "#6caea7",
      "Partially Correct" = "#f6e8c3",
      "Incorrect" = "#ef8a62"
    )
  ) +
  scale_x_continuous(labels = scales::percent, expand = c(5e-3, 5e-3)) +
  labs(
    x = "Percent",
    y = NULL,
    title = "Model performance on R code generation",
    fill = "Score"
  ) +
  theme_light() +
  theme(
    plot.subtitle = element_text(face = "italic"),
    legend.position = "bottom",
    plot.margin = margin(r = 10),
    axis.title = element_text(size = 14),
    title = element_text(size = 15),
    axis.text = element_text(size = 11.5),
    legend.text = element_text(size = 12)
  )
```

**For R coding tasks, we recommend using OpenAI's GPT-5 or o4-mini or Claude Sonnet 4.** OpenAIâ€™s o3 also scored well, but its cost was roughly ten times higher than o4-mini and about four times higher than GPT-5. Claude Sonnet 4 remains a competitive option for R code generation. Anecdotally, many R programmers seem to prefer Claude Sonnet to OpenAI's models.

::: {.callout-note}
## Reasoning vs. non-reasoning models
_Thinking_ or _reasoning_ models are LLMs that attempt to solve tasks through structured, step-by-step processing rather than just pattern-matching.  

Most of the models we looked at here are reasoning models, or are capable of reasoning. The only models not designed for reasoning are GPT-4.1 and Claude Sonnet 4 with thinking disabled. The gpt-oss models can perform reasoning, but lack a dedicated reasoning mode.
:::

```{r price-plot, dpi=300}
are_eval_summary <-
  are_eval |>
  group_by(model, model_join) |>
  summarize(percent_correct = sum(score == "Correct") / n()) |>
  ungroup() |>
  left_join(are_costs |> select(model_join, price), by = "model_join")

mean_correct <- mean(are_eval_summary$percent_correct)
mean_price <- mean(are_eval_summary$price)

are_eval_summary |>
  mutate(model = str_replace(model, "\n", " ")) |>
  # filter(!model %in% c("gpt-oss-120b", "gpt-oss-20b")) |>
  ggplot(aes(price, percent_correct)) +
  geom_point() +
  annotate(
    "text",
    x = -0.15,
    y = 0.675,
    label = "High performing,\ninexpensive",
    hjust = 0,
    vjust = 0,
    color = "#666666",
    size = 4
  ) +
  annotate(
    "text",
    x = 6.5,
    y = 0.4,
    label = "Lower performing,\nexpensive",
    hjust = 1,
    vjust = 0,
    color = "#666666",
    size = 4
  ) +
  geom_hline(
    yintercept = mean_correct,
    color = "#666666",
    linewidth = 1,
    alpha = 0.4
  ) +
  geom_vline(
    xintercept = mean_price,
    color = "#666666",
    linewidth = 1,
    alpha = 0.4
  ) +
  geom_label_repel(
    aes(label = model, fill = (model == "Claude Sonnet 4.5")),
    force = 0.4,
    seed = 5,
    nudge_x = 0.2,
    color = "#333333",
    # fill = "#f5f5f5",
    size = 4.2
  ) +
  scale_x_continuous(labels = scales::label_dollar()) +
  scale_y_continuous(
    labels = scales::label_percent(),
    breaks = scales::breaks_width(0.05)
  ) +
  scale_fill_manual(values = c("#f5f5f5", "#e6edff")) +
  coord_cartesian(xlim = c(0, 6.3), ylim = c(0.4, 0.7)) +
  labs(
    x = "Total cost",
    y = "Percent correct",
    title = "Model performance on R code generation vs. cost",
    subtitle = "Cost reflects the actual total charges incurred."
  ) +
  theme_light() +
  theme(
    plot.subtitle = element_text(face = "italic"),
    legend.position = "none",
    axis.title = element_text(size = 14),
    title = element_text(size = 15),
    axis.text = element_text(size = 12)
  )
```

::: {.callout-caution}
## Take token usage into account
A **token** is the fundamental unit of data that an LLM can process (for text processing, a token is approximately a word). Different models use different amounts of tokens, and reasoning models typically generate significantly more output tokens than non-reasoning models. As a result, a model that is inexpensive on a per-token basis can, in practice, cost much more if it produces longer outputs. 

In our evaluation, however, the models that generated the most tokens (GPT-5, GPT-5 nano, and o4-mini) were still among the least expensive overall.
:::

## Key insights

* **OpenAI's GPT-5, o4-mini, and o3 are the current best performers on the set of R coding tasks.**

    The GPT-5 family of models (released August 2025) are the newest models evaluated. 

* **OpenAI's newer models performed much better than its older models, GPT-4.1, o1, and o3-mini.**

* **Claude Sonnet 4 remains a reliable choice for R code generation**. On this evaluation, Claude Sonnet 4 performed slightly better with thinking enabled. 

## What about the open source models?

OpenAI recently released two open-weight models, gpt-oss-120b and gpt-oss-20b, which can be run locally or deployed on a platform like Hugging Face.

If you already work with open-weight models or have a specific reason to do so, these models, especially gpt-oss-120b, may be worth exploring. However, if your primary criterion is performance, they are unlikely to be the best choice compared to the top paid models.

Also, although open-weight models are technically free to use, you may still need to host them somewhere, which can incur significant costs.

## Pricing

LLM pricing is typically provided per million tokens. In our evaluation process, each model used between `r are_cost_summary$min_input` and `r are_cost_summary$max_input` input tokens and between `r are_cost_summary$min_output` and `r are_cost_summary$max_output` output tokens. The entire analysis cost around $`r round(are_cost_summary$total_cost, 0)`.

As noted above, although the gpt-oss models are free to use, you may need to pay to host them if you are unable to run them locally. 

```{r pricing-table}
model_prices |>
  left_join(are_costs, by = "model_join") |>
  mutate(
    Name = case_when(
      model_join == "sonnet_4_thinking" ~ "Claude Sonnet 4 (Thinking)",
      model_join == "sonnet_4" ~ "Claude Sonnet 4 (No Thinking)",
      .default = Name
    ),
    price = round(price, 2)
  ) |>
  select(
    Name,
    Input,
    Output,
    `Actual cost` = price,
    `Input tokens used` = input,
    `Output tokens used` = output
  ) |>
  gt() |>
  fmt_currency(columns = c(Input, Output, `Actual cost`), currency = "USD") |>
  fmt_number(
    columns = c(`Input tokens used`, `Output tokens used`),
    decimals = 0
  ) |>
  tab_header(
    title = "Model costs, in order of eval performance",
    subtitle = "Input and Output costs are per 1 million tokens. 'Actual cost' reflects total charges for running the evaluation."
  )
```


## Methodology

* We used [ellmer](https://ellmer.tidyverse.org/) to create connections to the various models and [vitals](https://vitals.tidyverse.org/) to evaluate model performance on R code generation tasks.
* We tested each model on a shared benchmark: the `are` dataset ("**A**n **R** **E**val"). `are` contains a collection of difficult R coding problems and a column, `target`, with information about the target solution.  
* Using vitals, we had each model solve each problem in `are`. Then, we scored their solutions using a scoring model (Claude 3.7 Sonnet). Each solution received either an Incorrect, Partially Correct, or Correct score. 

You can see all the code used to evaluate the models [here](https://github.com/skaltman/model-eval-r/blob/99b405a40b6b5f12ed03eba6d1f6d3d20620cd84/eval.R). If you'd like to see a more in-depth analysis, check out Simon Couch's series of [blog posts](https://www.simonpcouch.com/blog/), which this post is based on, including [Claude 4 and R Coding](https://www.simonpcouch.com/blog/2025-05-27-claude-4/). 
